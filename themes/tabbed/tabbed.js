/**
 * Copyright (c) 2018, Watermark
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function(profiles) {
	/**
	 * Class names used by elements generated by the tabbed theme
	 *
	 * @type {Object}
	 */

	var Class = {
		Tabs: {
			Container: 'dm-profile-tabs',
			Item: 'dm-profile-tabs__item',
			ItemActive: 'dm-profile-tabs__item--active',
			Link: 'dm-profile-tabs__link'
		},
		Break: 'dm-profile-break',
		Sections: {
			Base: 'dm-profile-sections'
		},
		Section: {
			Base: 'dm-profile-section',
			Hidden: 'dm-profile-section--hidden',
			Static: 'dm-profile-section--static',
			Tabbed: 'dm-profile-section--tabbed'
		},
		Content: 'dm-profile-content',
		MainImage: {
			TopLevel: 'dm-profile-preamble--with-main-image',
			Section: 'dm-profile-section--main-image',
			Image: 'dm-profile-main-image'
		},
		ReportSection: {
			Base: 'dm-profile-report-section'
		}
	};

	/**
	 * Keyboard arrow keys; used for improved tab control interactions
	 */
	var Keys = {
		Down: 40,
		Left: 37,
		Right: 39
	};

	/**
	 * Name of data attribute used to store hash value on tab controls and document sections
	 * @type {string}
	 */
	var HashAttribute = 'data-hash';

	/**
	 * Helper function for converting a class to a query selector
	 *
	 * @param {String} className a valid class name
	 * @returns {string} document query selector for the given class
	 */
	function toClassSelector(className) {
		return '.' + className;
	}

	/**
	 * Encodes the given text as a url hash.
	 *
	 * @param {string} value Text value to encode
	 * @returns {string} Encoded value as a valid url hash, including hash tag '#'
	 */
	function getHash(value) {
		return '#' + encodeURIComponent(value);
	}

	/**
	 * The given section's hash is the active tab if:
	 * * the hash matches the browser window's current hash, or
	 * * the browser window does not have a current hash, and the section is the first available tab
	 *
	 * @param {String} headingHash Encoded hash for the tabbed section
	 * @param {Integer} index Index of the section's hash in the set of all tabs
	 * @returns {boolean} `true` if the given hash is the active tab; else `false'
	 */
	function isTabSelected(headingHash, index) {
		var windowHash = window.location.hash;
		return !windowHash || windowHash.length === 0 || windowHash === '#'
			? index === 0
			: windowHash === headingHash;
	}

	/**
	 * Creates a given HTML element using the tag name, attributes, and value specified
	 *
	 * @param {String} nodeName Name of the DOM node to create
	 * @param {Object} attributes Optional; key/value pairs for attributes to be added to the element
	 * @param {String} innerHtml Optional; inner value of the generated element. Expected to be a string; not another DOM element.
	 * 		To attach child elements, use `appendChild` on the returned element instead.
	 * @returns {HTMLElement} The generated element
	 */
	function createEl(nodeName, attributes, innerHtml) {
		var result = document.createElement(nodeName);

		var attrs = attributes || {};
		Object.keys(attrs).forEach(function(attributeName) {
			result.setAttribute(attributeName, attributes[attributeName]);
		});

		if (innerHtml) {
			result.innerHTML = innerHtml;
		}

		return result;
	}

	/**
	 * Creates the base container which holds controls for switching between tabs of a profile
	 *
	 * @returns {HTMLElement} Container for tab controls
	 */
	function createTabControlsContainer() {
		return createEl('ul', {
			class: Class.Tabs.Container,
			role: 'tablist'
		});
	}

	/**
	 * Provides arrow key interactivity for tab control links
	 *
	 * @param event keyboard event
	 */
	function onTabLinkKeydown(event) {
		var link = event.currentTarget;
		if (link.tabIndex === '-1') {
			return;
		}
		switch (event.which) {
			case Keys.Down:
				// For screen readers, down arrow should move from the tabbed control to the currently active contents
				event.preventDefault();
				document
					.querySelector(
						'.' + Class.Section.Tabbed + ':not(.' + Class.Section.Hidden + ')'
					)
					.focus();
				break;
			case Keys.Right:
				// If there is another tab link to the right, move to it
				var nextTab = link.parentNode.nextSibling;
				if (nextTab) {
					var nextLink = nextTab.children[0];
					nextLink.click();
					nextLink.focus();
				}
				break;
			case Keys.Left:
				// If there is another tab link to the left, move to it
				var previousTab = link.parentNode.previousSibling;
				if (previousTab) {
					var previousLink = previousTab.children[0];
					previousLink.click();
					previousLink.focus();
				}
				break;
		}
	}

	/**
	 * Creates an element representing the tab control for an individual tabbed section of a profile.
	 * Includes correct styling and attributes to indicate if the given section should be the active tab.
	 *
	 * @param {tabbedSection} tabbedSection Section of the web profile for which a tab control should be created
	 * @param {Integer} index Position of the tabbed section within the list of all tabbed sections.
	 * @returns {HTMLElement} Tab control for the given profile section
	 */
	function createTabControlEl(tabbedSection, index) {
		var headingHash = getHash(tabbedSection.heading.value);
		var isSelected = isTabSelected(headingHash, index);
		var itemClass =
			Class.Tabs.Item + (isSelected ? ' ' + Class.Tabs.ItemActive : '');
		var link = createEl(
			'a',
			{
				class: Class.Tabs.Link,
				role: 'tab',
				href: headingHash,
				'aria-selected': isSelected,
				tabindex: isSelected ? '0' : '-1'
			},
			tabbedSection.heading.value
		);
		link.addEventListener('keydown', onTabLinkKeydown);
		var attrs = {
			class: itemClass,
			role: 'presentation'
		};
		attrs[HashAttribute] = headingHash;
		var listItem = createEl('li', attrs);
		listItem.appendChild(link);
		return listItem;
	}

	/**
	 * Creates the element controls for switching between tabs of a profile.
	 *
	 * @param {profile} profile The profile for which to generate tabbed controls
	 * @returns {HTMLElement} The root element containing controls for switching between tabs
	 */
	function renderTabbedControls(profile) {
		var tabControlsContainer = createTabControlsContainer();
		profile.contentSections.forEach(function(sections, index) {
			tabControlsContainer.appendChild(createTabControlEl(sections[0], index));
		});
		return tabControlsContainer;
	}

	/**
	 * Creates a container element for a single tabbed section of a web profile document.
	 *
	 * @param {section} section Tabbed section of a profile for which a root element should be created
	 * @param {array} tabbedSections Ordered list of all tabbed sections for the profile
	 * @returns {HTMLElement} Container of an individual tabbed section of a profile
	 */
	function renderDocumentTab(sections, contentSectionIndex) {
		var headingHash = getHash(sections[0].heading.value);
		var isSelected = isTabSelected(headingHash, contentSectionIndex);

		var modifierClass = isSelected
			? Class.Section.Tabbed
			: Class.Section.Tabbed + ' ' + Class.Section.Hidden;
		var className = Class.Section.Base + ' ' + modifierClass;
		var attrs = {
			class: className,
			tabIndex: '-1'
		};
		attrs[HashAttribute] = headingHash;

		var el = createEl('section', attrs);
		sections.forEach(function(section) {
			el.appendChild(section.render());
		});
		return el;
	}

	/**
	 * Creates the tabbed view of the profile. Each tab is placed in its own root element, with only the
	 * active tab's element showing. This enables easy tab switching without re-fetching / re-rendering
	 * individual report sections.
	 *
	 * @param {profile} profile profile to render
	 * @returns {HTMLElement} Root element containing all tabbed sections of the profile
	 */
	function renderTabbedDocument(profile) {
		var result = createEl('div', {
			class: Class.Sections.Base
		});

		profile.contentSections.forEach(function(sections, contentSectionIndex) {
			result.appendChild(renderDocumentTab(sections, contentSectionIndex));
		});

		return result;
	}

	/**
	 * Utility to add a class to an element
	 * @param {HTMLElement} el
	 * @param {String} className
	 */
	function addClass(el, className) {
		el.className += ' ' + className;
	}

	/**
	 * Takes the bare image element and wraps it in a `div` that will be put in
	 * as the first section of the static area.
	 * @param {HTMLImageElement} imageEl
	 * @returns {HTMLDivElement}
	 */
	function createMainImageSection(imageEl) {
		var profileImgWrapper = createEl('div', {
			class: Class.Section.Base + ' ' + Class.MainImage.Section
		});
		profileImgWrapper.appendChild(imageEl);
		return profileImgWrapper;
	}

	/**
	 * Determines if the given element has at least one child with text or image content
	 * @param {HTMLElement} parent element
	 * @returns {boolean} true if empty; false if not empty
	 */
	function isElementEmpty(domElement) {
		var result = domElement.getElementsByTagName('img').length === 0;

		if (result) {
			Array.prototype.filter
				.call(domElement.children, function(tag) {
					return tag.tagName !== 'STYLE';
				})
				.forEach(function(childEl) {
					if (childEl.textContent.trim().length !== 0) {
						result = false;
					}
				});
		}

		return result;
	}

	/**
	 * Moves the profile image from its location in the preamble and places it at the
	 * beginning of the area.
	 * @param {HTMLElement} result
	 * @param {HTMLImageElement} image
	 */
	function moveProfileImage(result, image) {
		var parent = image.parentNode;
		image.parentNode.removeChild(image);
		image.removeAttribute('width');
		image.removeAttribute('height');
		addClass(image, Class.MainImage.Image);
		addClass(result, Class.MainImage.TopLevel);
		result.insertBefore(createMainImageSection(image), result.children[0]);

		while (parent && isElementEmpty(parent)) {
			var newParent = parent.parentNode;
			newParent.removeChild(parent);
			parent = newParent;
		}
	}

	/**
	 * Renders the preamble for the tabbed profile.
	 * All items at top of report before the first web profile content section are part of the preamble.
	 * The first image inside of the preamble is also rehoused and treated as a profile picture for this theme.
	 *
	 * @param {profile} profile profile to render
	 * @returns {HTMLElement} the root HTML element containing the static section.
	 */
	function renderPreambleSection(profile) {
		var result = profile.renderPreamble();

		var images = result.getElementsByTagName('img');
		if (images.length) {
			moveProfileImage(result, images[0]);
		}

		return result;
	}

	/**
	 * Grab existing rendered tab controls, remove the active class from all, and
	 * append the active class to whichever matches the browser window's current hash
	 */
	function updateActiveTab() {
		var tabs = document.querySelectorAll(
			toClassSelector(Class.Tabs.Item) + '[' + HashAttribute + ']'
		);
		var regex = new RegExp('(\\s|^)' + Class.Tabs.ItemActive + '(\\s|$)');
		Array.prototype.forEach.call(tabs, function(tab, index) {
			var link = tab.querySelector('.' + Class.Tabs.Link);
			if (tab.className.match(regex)) {
				tab.className = tab.className.replace(regex, ' ');
				link.setAttribute('aria-selected', 'false');
				link.setAttribute('tabindex', '-1');
			}
			if (isTabSelected(tab.getAttribute(HashAttribute), index)) {
				tab.className += ' ' + Class.Tabs.ItemActive;
				link.setAttribute('aria-selected', 'true');
				link.setAttribute('tabindex', '0');
			}
		});
	}

	/**
	 * Grab each web profile document section, remove the active class from all, and
	 * append the active class to whichever matches the browser window's current hash
	 */
	function updateActiveSection() {
		var tabHeadingSections = document.querySelectorAll(
			toClassSelector(Class.Section.Base) + '[' + HashAttribute + ']'
		);
		var regex = new RegExp('(\\s|^)' + Class.Section.Hidden + '(\\s|$)');
		Array.prototype.forEach.call(tabHeadingSections, function(section, index) {
			if (!section.className.match(regex)) {
				section.className += ' ' + Class.Section.Hidden;
			}
			if (isTabSelected(section.getAttribute(HashAttribute), index)) {
				section.className = section.className.replace(regex, ' ');
			}
		});
	}

	/**
	 * When the browser window's hash changes, a new tab was selected.
	 * Update both the active tab control, and the section of the profile displayed
	 */
	function onHashChange() {
		updateActiveTab();
		updateActiveSection();
	}

	/**
	 * Renders the tabbed view of the web profile, and sets up handling for switching between tabs.
	 *
	 * @param {profile} profile The profile to render
	 * @returns {HTMLDivElement} Root element containing the tabbed profile
	 */
	function renderTabbedProfile(profile) {
		var result = document.createElement('div');

		if (profile.preambleSections) {
			result.appendChild(renderPreambleSection(profile));
		}

		result.appendChild(renderTabbedControls(profile));
		result.appendChild(
			createEl('hr', {
				class: Class.Break
			})
		);
		result.appendChild(renderTabbedDocument(profile));

		window.addEventListener('hashchange', onHashChange);

		return result;
	}

	/**
	 * If there is a `profile` on the given param, then render it as a tabbed profile.
	 * Otherwise, fall back to the default rendering (i.e., for loading profile / handling errors)
	 *
	 * @param {webProfile} webProfile The web profile object.
	 * @returns {HTMLElement} Element containing rendered web profile
	 */
	function renderTabbed(webProfile) {
		var result;

		if (webProfile.profile) {
			if (!webProfile.profile.contentSections) {
				result = webProfile.renderError(
					'No web profile content sections have been included inside report template.'
				);
			} else {
				result = renderTabbedProfile(webProfile.profile);
			}
		} else {
			result = webProfile.render();
		}

		return result;
	}

	if (!profiles) {
		throw new Error(
			'window.dmWebProfiles does not exist. Please include the dm-web-profiles javascript asset first.'
		);
	}

	if (!profiles.themes) {
		throw new Error(
			'window.dmWebProfiles.themes does not exist. Please ensure dm-web-profiles javascript asset is included.'
		);
	}

	if (profiles.themes.tabbed) {
		throw new Error(
			'window.dmWebProfiles.themes.tabbed already exists. Only one instance of dm-web-profiles allowed per page.'
		);
	} else {
		profiles.themes.tabbed = renderTabbed;
	}
})(window.dmWebProfiles);
